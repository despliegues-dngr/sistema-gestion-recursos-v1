---
description: Convenciones de estilo de c√≥digo para TypeScript y frameworks frontend
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.vue"
  - "**/*.jsx"
  - "src/components/**/*"
  - "src/composables/**/*"
  - "src/hooks/**/*"
alwaysApply: false
---

# üé® Gu√≠as de Estilo de C√≥digo

## TypeScript

### Tipos y Interfaces

- ‚úÖ **Preferir `interface`** para objetos y formas de datos
- ‚úÖ Usar `type` para uniones, intersecciones y alias simples
- ‚úÖ Definir tipos expl√≠citos en funciones p√∫blicas

```typescript
// ‚úÖ Bueno
interface User {
  id: string
  name: string
  role: 'admin' | 'supervisor' | 'operador'
}

type UserRole = 'admin' | 'supervisor' | 'operador'

// ‚ùå Evitar any
function processData(data: any) { } // ‚ùå
function processData(data: unknown) { } // ‚úÖ
```

### Configuraci√≥n TypeScript

- Seguir configuraci√≥n en `tsconfig.json` y archivos relacionados
- Mantener strict mode activado
- Usar paths `@/` para imports absolutos cuando est√© configurado

### Servicios y Stores

- ‚úÖ Tipar todos los m√©todos de servicio
- ‚úÖ Usar tipos espec√≠ficos para stores (Pinia, Zustand, Redux, etc.)
- ‚úÖ Documentar tipos complejos con JSDoc cuando sea necesario

```typescript
// ‚úÖ Ejemplo de servicio tipado
export interface DatabaseRecord {
  id: string
  createdAt: number
  updatedAt: number
}

export class DatabaseService {
  async create<T extends DatabaseRecord>(table: string, data: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<T> {
    // ...
  }
}
```

### Manejo de Errores

- ‚úÖ Usar tipos espec√≠ficos para errores cuando sea posible
- ‚úÖ Preferir `Result<T, E>` pattern para operaciones que pueden fallar
- ‚úÖ No usar `any` para errores

### Imports

- ‚úÖ Organizar imports: externos primero, luego locales
- ‚úÖ Usar imports absolutos con `@/` para c√≥digo local cuando est√© configurado
- ‚úÖ Evitar imports circulares

---

## Frameworks Frontend

### Composition API / Hooks Pattern

- ‚úÖ **Siempre usar Composition API** con `<script setup lang="ts">` (Vue)
- ‚úÖ Usar hooks personalizados (React) o composables (Vue)
- ‚úÖ Usar `defineProps`, `defineEmits` con TypeScript (Vue)
- ‚ùå **NO usar Options API** (Vue) o class components (React) excepto migraciones existentes

### Estructura de Componentes

#### Vue 3 (Composition API)
```vue
<script setup lang="ts">
// 1. Imports externos
import { ref, computed } from 'vue'
import type { ComponentType } from 'vue'

// 2. Imports locales (@/)
import { useAuth } from '@/composables/useAuth'

// 3. Props y Emits
interface Props {
  // ...
}
const props = defineProps<Props>()
const emit = defineEmits<{ event: [value: string] }>()

// 4. Composables
const { user } = useAuth()

// 5. Estado reactivo
const count = ref(0)

// 6. Computed
const doubled = computed(() => count.value * 2)

// 7. M√©todos
function increment() {
  count.value++
}

// 8. Lifecycle hooks
onMounted(() => {
  // ...
})
</script>

<template>
  <!-- Template content -->
</template>

<style scoped lang="scss">
/* Component styles */
</style>
```

#### React (Hooks)
```tsx
// 1. Imports externos
import { useState, useEffect } from 'react'

// 2. Imports locales
import { useAuth } from '@/hooks/useAuth'

// 3. Props
interface Props {
  // ...
}

// 4. Component
export function Component({ ...props }: Props) {
  // 5. Hooks
  const { user } = useAuth()
  const [count, setCount] = useState(0)

  // 6. Computed/derived state
  const doubled = count * 2

  // 7. Effects
  useEffect(() => {
    // ...
  }, [])

  // 8. Handlers
  function increment() {
    setCount(c => c + 1)
  }

  return (
    // JSX content
  )
}
```

### Convenciones de Nombrado

- **Componentes:** PascalCase: `UserTable.vue`, `LoginForm.tsx`
- **Composables/Hooks:** camelCase con prefijo `use`: `useAuth.ts`, `useDatabase.ts`
- **Props:** camelCase: `userName`, `isLoading`
- **Emits/Events:** kebab-case en template: `@user-updated`, `onUserUpdated`

### Librer√≠as UI

- ‚úÖ Seguir gu√≠as de la librer√≠a UI del proyecto
- ‚úÖ Usar componentes de la librer√≠a para consistencia UI
- ‚úÖ Aplicar sistema de dise√±o definido en el proyecto

### Composable/Hook Pattern

- Extraer l√≥gica reutilizable a composables/hooks
- Cada composable/hook debe tener una responsabilidad √∫nica
- Usar TypeScript con tipos expl√≠citos

### Template/JSX Best Practices

- ‚úÖ Usar renderizado condicional apropiado (`v-if` / `{condition && <Component />}`)
- ‚úÖ Usar loops con keys siempre (`v-for :key` / `map(key)`)
- ‚úÖ Evitar l√≥gica compleja en template/JSX (mover a computed/derived state o m√©todos)
